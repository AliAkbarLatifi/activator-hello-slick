import scala.slick.driver.H2Driver.simple._

// A Suppliers table with 6 columns: id, name, street, city, state, zip
class Suppliers(tag: Tag) extends Table[(Int, String, String, String, String, String)](tag, "SUPPLIERS") {
  def id = column[Int]("SUP_ID", O.PrimaryKey) // This is the primary key column
  def name = column[String]("SUP_NAME")
  def street = column[String]("STREET")
  def city = column[String]("CITY")
  def state = column[String]("STATE")
  def zip = column[String]("ZIP")
  // Every table needs a * projection with the same type as the table's type parameter
  def * = (id, name, street, city, state, zip)
}

// A Coffees table with 5 columns: name, supplier id, price, sales, total
class Coffees(tag: Tag) extends Table[(String, Int, Double, Int, Int)](tag, "COFFEES") {
  def name = column[String]("COF_NAME", O.PrimaryKey)
  def supID = column[Int]("SUP_ID")
  def price = column[Double]("PRICE")
  def sales = column[Int]("SALES")
  def total = column[Int]("TOTAL")
  def * = (name, supID, price, sales, total)
  // A reified foreign key relation that can be navigated to create a join
  def supplier = foreignKey("SUP_FK", supID, TableQuery[Suppliers])(_.id)
}

// The main application
object Hello extends App {
  
  // The query interface for the Suppliers table
  val suppliers = TableQuery[Suppliers]
  
  // the query interface for the Coffees table
  val coffees = TableQuery[Coffees]

  // Create a connection (called a "session") to an in-memory H2 database
  Database.forURL("jdbc:h2:mem:test1", driver = "org.h2.Driver") withSession { implicit session =>
    // Create the schema by combining the DDLs for the Suppliers and Coffees tables using the query interface from the companion objects
    (suppliers.ddl ++ coffees.ddl).create

    // Insert some suppliers
    suppliers += (101, "Acme, Inc.", "99 Market Street", "Groundsville", "CA", "95199")
    suppliers += (49, "Superior Coffee", "1 Party Place", "Mendocino", "CA", "95460")
    suppliers += (150, "The High Ground", "100 Coffee Lane", "Meadows", "CA", "93966")

    // Insert some coffees (using JDBC's batch insert feature)
    val coffeesInsertResult: Option[Int] = coffees ++= Seq (
      ("Colombian",         101, 7.99, 0, 0),
      ("French_Roast",       49, 8.99, 0, 0),
      ("Espresso",          150, 9.99, 0, 0),
      ("Colombian_Decaf",   101, 8.99, 0, 0),
      ("French_Roast_Decaf", 49, 9.99, 0, 0)
    )

    // Print the number of rows inserted
    coffeesInsertResult foreach (numRows => println(s"Inserted $numRows rows into the Coffees table"))

    // Print the SQL for the Coffees query
    println("Generated SQL for base Coffees query:\n" + coffees.selectStatement)

    // Query the Coffees table using a foreach and print each row
    coffees foreach { case (name, supID, price, sales, total) =>
      println("  " + name + "\t" + supID + "\t" + price + "\t" + sales + "\t" + total)
    }
  
  
    // Why not let the database do the string conversion and concatenation?
    val q1: Query[Column[String], String] = for(c <- coffees)
      yield LiteralColumn("  ") ++ c.name ++ "\t" ++ c.supID.asColumnOf[String] ++
        "\t" ++ c.price.asColumnOf[String] ++ "\t" ++ c.sales.asColumnOf[String] ++
        "\t" ++ c.total.asColumnOf[String]
    // The first string constant needs to be lifted manually to a LiteralColumn
    // so that the proper ++ operator is found

    println("Generated SQL for the q1 query:\n" + q1.selectStatement)

    // Print the rows which are now just a long string generated by the database
    q1 foreach println
  
  
    // Perform a join to retrieve coffee names and supplier names for
    // all coffees costing less than $9.00
    val q2: Query[(Column[String], Column[String]), (String, String)] = for {
      c <- coffees if c.price < 9.0
      s <- suppliers if s.id === c.supID
    } yield (c.name, s.name)

    println("Generated SQL for the q2 query:\n" + q2.selectStatement)
  
    // Print the rows which contain the coffee name and the supplier name
    q2 foreach { case (coffee, supplier) => 
      println(s"Coffee: $coffee \t Supplier: $supplier")
    }

  
    // Join the tables using the relationship defined in the Coffees table
    val q3: Query[(Column[String], Column[String]), (String, String)] = for {
      c <- coffees if c.price > 9.0
      s <- c.supplier
    } yield (c.name, s.name)

    println("Generated SQL for the q3 query:\n" + q3.selectStatement)

    // Print the rows which contain the coffee name and the supplier name
    q3 foreach { case (coffee, supplier) =>
      println(s"Coffee: $coffee \t Supplier: $supplier")
    }
    
  }
}